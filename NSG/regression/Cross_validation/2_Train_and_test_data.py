import sys
sys.path.append('../..')
sys.path.append('../../../..')
import pandas as pd
import numpy as np
from matplotlib import pyplot as plt
import data_processing_methods as dpm

"""
The k-fold generated files are manually saved in the corresponding M region
folder. For example, for "end = 2*800" the corresponding folder should be
"M_2_Training_and_Testing"
"""

# plt.close('all')
# ----------------------------------------------------------------------------
# USER OPTIONS
# ----------------------------------------------------------------------------

to_retain = ['10271 Open Crown Temperature - Upstream Refiner (PV)',
'9400 Port 2 Gas Flow (SP)',
'2922 Closed Bottom Temperature - Downstream Working End (PV)',
'7746 Open Crown Temperature - Port 2 (PV)',
'10091 Furnace Load',
'200000 Front Wall Temperature Average (PV)',
'2921 Closed Bottom Temperature - Upstream Working End (PV)',
'7546 Open Crown Temperature - Port 1 (PV)',
'2918 Closed Bottom Temperature - Port 6 (PV)',
'2913 Closed Bottom Temperature - Port 1 (PV)',
'1650 Combustion Air Temperature Measurement',
'10425 Calculated Cullet Ratio',
'7673 Open Crown Temperature - Port 5 (PV)',
'7483 Open Crown Temperature - Port 6 (PV)',
'9400 Port 2 Gas Flow (SP)']

# ----------------------------------------------------------------------------
# LOAD DATA
# ----------------------------------------------------------------------------

# Load data frames
scanner = 'MK4'

if scanner == 'MK4':
    file_name = '../../../../Input Post-Processing 3 MK4 2021_07_01.xlsx'
else:
    file_name = '../../../../Input Post-Processing 3 ISRA 2021_07_05.xlsx'
    
X_df = pd.read_excel(file_name, sheet_name='input_data')
Y_df = pd.read_excel(file_name, sheet_name='output_data')
T_df = pd.read_excel(file_name, sheet_name='time_lags')
Y_raw_df = pd.read_excel(file_name, sheet_name='raw_output_data')
stand_df = pd.read_excel(file_name, sheet_name='Statistics')

# ----------------------------------------------------------------------------
# MANUALLY IGNORE INPUTS
# ----------------------------------------------------------------------------

input_names = X_df.columns
for name in input_names:
    if name not in to_retain:
        X_df.drop(columns=name, inplace=True)
        T_df.drop(columns=name, inplace=True)

# ----------------------------------------------------------------------------
# PRE-PROCESSING
# ----------------------------------------------------------------------------

# Finding raw fault density mean and std (at training points)
Y_mean = np.mean(Y_df['furnace_faults'].values)
Y_std = np.std(Y_df['furnace_faults'].values)

# Standardise training data
for i in range(np.shape(X_df)[1]):
    tag_name = X_df.columns[i]

    # Re-write X_df now with standardise data (at training points)
    X_df[tag_name] = dpm.standardise(X_df.iloc[:, i],
                                     np.mean(X_df.iloc[:, i]),
                                     np.std(X_df.iloc[:, i]))

# Process data
X, Y, N, D, max_lag, timelags  = dpm.align_arrays(X_df, Y_df, T_df)

# Process raw target data in the same way as the post-processed
# target data. Note this essentially just removes the first max_lag
# points from the date_time array.
Y_raw = dpm.adjust_time_lag(Y_raw_df['raw_furnace_faults'].values,
                            shift=0,
                            to_remove=max_lag)

# Y_raw standardisation
Y_raw_mean = np.mean(Y_raw_df['raw_furnace_faults'].values)
Y_raw_std = np.std(Y_raw_df['raw_furnace_faults'].values)
Y_raw_stand = dpm.standardise(Y_raw, Y_raw_mean, Y_raw_std)

# Extract corresponding time stamps. Note this essentially just
# removes the first max_lag points from the date_time array.
date_time = dpm.adjust_time_lag(Y_df['Time stamp'].values, shift=0,
                               to_remove=max_lag)

# Real increase generated by the furnace process (01/08/2020 to 01/09/2020) 
start = 5*1000
end = 6*1000
X = X[start: end]
y = Y[start: end]
y_raw = Y_raw[start: end]
dt = date_time[start:end]
N = end - start

#-----------------------------------------------------------------------------
# APPLY K-FOLD CROSS-VALIDATION
#-----------------------------------------------------------------------------

# The indices of the training and testing data
indices = np.arange(N)

# Training and tesitng data for 1-fold
train_d = {}
test_d = {}

# Start and end of each test data
start = [0, 354,  708]
end = [88, 442, 796]
step = end[0] - start[0]
N_test = 88

# Create dictionary with the training data (outputs included)
kfold = 3
i_train = np.zeros((N-N_test, kfold))
i_test = np.zeros((N_test,kfold))

# Get the indices of the test data
for k in range(kfold):
    i_test[:,k] = np.arange(start[k], end[k])
    
# Get the indices of the training data
for k in range(kfold):
    i_train[:,k] =np.sort(list(set(list(np.arange(N)))^set(list(i_test[:,k]))))


# Assemble the k-fold training and testing data in a spreadsheet
for k in range(kfold):
    # Convert indices elements into int type
    temp_train = [int(i) for i in i_train[:,k]]
    temp_test = [int(i) for i in i_test[:,k]]
    
    for d in range(D):
        train_d[X_df.columns[d]] = X[temp_train, d]
        test_d[X_df.columns[d]] = X[temp_test, d]
    
    # Include the outputs and date-time in each set
    train_d['y'] = y_raw[temp_train]
    train_d['DateTime'] = dt[temp_train]
    test_d['y'] = y[temp_test]
    test_d['DateTime'] = dt[temp_test]
    
    # Create data frames of final processed train and test dataset
    # and save as excel file
    train_df = pd.DataFrame(train_d)
    test_df = pd.DataFrame(test_d)
    
    # Define an Excel writer object
    writer = pd.ExcelWriter(str(k)+'-fold' + r'.xlsx')
    
    # Save to spreadsheet
    train_df.to_excel(writer, sheet_name=str(k)+'-train', index='DateTime')
    test_df.to_excel(writer, sheet_name=str(k)+'-test', index='DateTime')
    writer.save()

# Plot training and testing regions
fig, ax = plt.subplots()
ax.set_title(" Cross-validation", fontsize=20)
ax.plot(dt, y_raw, color='black', label='Raw FFD')
ax.plot(dt, y, color='blue', label='Filtered FFD')
for k in range(kfold):
    ax.axvline(dt[start[k]], color='red', label='Test'+str(k))
    ax.axvline(dt[end[k]], color='red', label='Test'+str(k))

fig.autofmt_xdate()
plt.legend()
ax.set_xlabel('Date', fontsize=17)
ax.set_ylabel('Fault density', fontsize=17)

plt.show()